// Code generated by cmd/lexgenlite (see Makefile's lexgen); DO NOT EDIT.

package bsky

// schema: app.bsky.graph.list

import (
	"encoding/json"
	"fmt"

	comatprototypes "github.com/agentio/atiquette/api/com/atproto"
	"github.com/agentio/atiquette/pkg/lexutil"
)

func init() {
	lexutil.RegisterType("app.bsky.graph.list", &GraphList{})
}

// RECORDTYPE: GraphList
type GraphList struct {
	LexiconTypeID     string            `json:"$type,const=app.bsky.graph.list" cborgen:"$type,const=app.bsky.graph.list"`
	Avatar            *lexutil.LexBlob  `json:"avatar,omitempty" cborgen:"avatar,omitempty"`
	CreatedAt         string            `json:"createdAt" cborgen:"createdAt"`
	Description       *string           `json:"description,omitempty" cborgen:"description,omitempty"`
	DescriptionFacets []*RichtextFacet  `json:"descriptionFacets,omitempty" cborgen:"descriptionFacets,omitempty"`
	Labels            *GraphList_Labels `json:"labels,omitempty" cborgen:"labels,omitempty"`
	// name: Display name for list; can not be empty.
	Name string `json:"name" cborgen:"name"`
	// purpose: Defines the purpose of the list (aka, moderation-oriented or curration-oriented)
	Purpose *string `json:"purpose" cborgen:"purpose"`
}

type GraphList_Labels struct {
	LabelDefs_SelfLabels *comatprototypes.LabelDefs_SelfLabels
}

func (t *GraphList_Labels) MarshalJSON() ([]byte, error) {
	if t.LabelDefs_SelfLabels != nil {
		t.LabelDefs_SelfLabels.LexiconTypeID = "com.atproto.label.defs#selfLabels"
		return json.Marshal(t.LabelDefs_SelfLabels)
	}
	return nil, fmt.Errorf("cannot marshal empty enum")
}
func (t *GraphList_Labels) UnmarshalJSON(b []byte) error {
	typ, err := lexutil.TypeExtract(b)
	if err != nil {
		return err
	}

	switch typ {
	case "com.atproto.label.defs#selfLabels":
		t.LabelDefs_SelfLabels = new(comatprototypes.LabelDefs_SelfLabels)
		return json.Unmarshal(b, t.LabelDefs_SelfLabels)

	default:
		return nil
	}
}
